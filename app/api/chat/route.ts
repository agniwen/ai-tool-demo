import { createGoogleGenerativeAI } from "@ai-sdk/google";
import {
  clipResumeText,
  collectUploadedResumePdfs,
  extractResumeStructuredInfo,
  parseResumePdf,
  selectUploadedResumePdfs,
  type ParsedResumePdf,
  type UploadedResumePdf,
} from "@/lib/resume-pdf";
import {
  convertToModelMessages,
  stepCountIs,
  streamText,
  tool,
  type UIMessage,
} from "ai";
import { z } from "zod";

// Allow streaming responses up to 8 minutes
export const maxDuration = 480;
export const runtime = "nodejs";

const extractUserText = (messages: UIMessage[]): string =>
  messages
    .filter((message) => message.role === "user")
    .flatMap((message) => message.parts)
    .filter((part) => part.type === "text")
    .map((part) => part.text)
    .join("\n")
    .trim();

const inferRoleFromText = (text: string): string | null => {
  const normalized = text.replace(/\s+/g, " ").trim();

  if (!normalized) {
    return null;
  }

  const roleKeywordMap: Array<{ keyword: RegExp; role: string }> = [
    { keyword: /行政/, role: "行政实习生" },
    { keyword: /人事|HR/, role: "人力资源实习生" },
    { keyword: /运营/, role: "运营实习生" },
    { keyword: /产品/, role: "产品实习生" },
    { keyword: /前端/, role: "前端开发实习生" },
    { keyword: /后端|服务端|后台/, role: "后端开发实习生" },
    { keyword: /测试|QA/, role: "测试实习生" },
    { keyword: /数据分析|数据/, role: "数据分析实习生" },
    { keyword: /设计|UI|UX/, role: "设计实习生" },
    { keyword: /财务/, role: "财务实习生" },
  ];

  for (const item of roleKeywordMap) {
    if (item.keyword.test(normalized)) {
      return item.role;
    }
  }

  const patterns = [
    /(?:我需要招聘|我们需要招聘|需要招聘|招聘)\s*([^，。；\n]{1,24})/,
    /(?:我需要|我们需要|需要)\s*([^，。；\n]{1,24})(?:岗位|职位|方向|人员)?/,
  ];

  for (const pattern of patterns) {
    const match = normalized.match(pattern);

    if (!match?.[1]) {
      continue;
    }

    const role = match[1]
      .replace(/(一名|一位|一个|若干|实习生|岗位|职位|方向|人员|的)/g, "")
      .trim();

    if (role.length > 0) {
      return role.includes("实习") ? role : `${role}实习生`;
    }
  }

  return null;
};

const buildAutoJobDescription = (role: string): string => {
  if (role.includes("行政")) {
    return `岗位名称: 行政实习生
岗位目标: 保障部门日常行政与协同流程高效运转
核心职责:
- 协助会议安排、来访接待、办公用品及固定资产管理
- 处理文档归档、数据录入、报销单据和流程跟进
- 配合跨部门沟通与活动执行支持
能力要求:
- 熟练使用办公软件（Word/Excel/PPT）
- 做事细致、执行力强、时间管理良好
- 具备基础沟通协调能力与服务意识
加分项:
- 有行政助理、学生组织事务或活动统筹经验
- 每周可到岗 4 天及以上，连续实习 3 个月及以上`;
  }

  return `岗位名称: ${role}
岗位目标: 支持团队完成基础业务与协同工作，培养岗位胜任力
核心职责:
- 承担岗位相关的执行与协作任务
- 参与项目推进、信息整理与跨团队沟通
- 输出过程文档、周报或阶段性成果
能力要求:
- 具备岗位相关的基础知识与学习能力
- 沟通清晰、执行稳定、按时交付
- 责任心强，能在反馈中持续改进
加分项:
- 有相关项目/实习/校园实践经历
- 每周可到岗 4 天及以上，连续实习 3 个月及以上`;
};

export async function POST(req: Request) {
  const {
    jobDescription,
    messages,
  }: {
    jobDescription?: string;
    messages: UIMessage[];
  } = await req.json();

  const apiKey = process.env.GOOGLE_GENERATIVE_AI_API_KEY;

  if (!apiKey) {
    return new Response(
      "Missing GOOGLE_GENERATIVE_AI_API_KEY. Please configure your environment variables.",
      { status: 500 }
    );
  }

  const baseURL = process.env.GOOGLE_GENERATIVE_AI_BASE_URL?.trim();

  const provider = createGoogleGenerativeAI({
    apiKey,
    ...(baseURL ? { baseURL } : {}),
  });

  const modelId = process.env.GOOGLE_MODEL ?? "gemini-3-flash-preview";
  const normalizedJobDescription = jobDescription?.trim();
  const uploadedResumePdfs = collectUploadedResumePdfs(messages);
  const uploadedResumeFiles = uploadedResumePdfs.length > 0;
  const userText = extractUserText(messages);
  const inferredRole = inferRoleFromText(userText);
  const autoGeneratedJd = inferredRole
    ? buildAutoJobDescription(inferredRole)
    : null;

  const parsedResumeCache = new Map<string, Promise<ParsedResumePdf>>();

  const parseUploadedResume = (file: UploadedResumePdf) => {
    const cached = parsedResumeCache.get(file.id);

    if (cached) {
      return cached;
    }

    const task = parseResumePdf(file);
    parsedResumeCache.set(file.id, task);
    return task;
  };

  const availableResumeNames = uploadedResumePdfs.map(
    (file, index) => `${index + 1}. ${file.filename}`
  );

  const selectResumeFiles = (resumeName?: string) =>
    selectUploadedResumePdfs(uploadedResumePdfs, resumeName);

  const jdContext = normalizedJobDescription
    ? `Configured JD from settings (secondary context):\n${normalizedJobDescription}`
    : "No JD is configured in settings.";

  const autoJdContext = autoGeneratedJd
    ? `Auto-generated JD from user text:\n${autoGeneratedJd}`
    : "No auto-generated JD from user text.";

  const result = streamText({
    model: provider(modelId),
    system: `You are an internship resume screening assistant.
Your goal is to help recruiters quickly assess intern candidates.
Keep responses concise and structured.
When suitable, provide: overall recommendation (interview / hold / reject), score (0-100), strengths, risks, and follow-up interview questions.
JD priority rules:
1) If the user explicitly provides or updates a JD in the chat prompt, use that as the primary JD.
2) If the user only provides a hiring intent like "我需要招聘行政", use the auto-generated JD as the primary working JD.
3) Use the configured JD from settings only as secondary context.
4) If still missing, make explicit assumptions and continue.
Interaction rules:
- Do not block the user with repeated information requests.
- If resume files are available, always give a first-pass evaluation immediately, then ask at most 3 targeted follow-up questions.
- If data is incomplete, provide a provisional ranking with confidence notes instead of refusing.
PDF resume parsing rules:
- The PDF tools are auxiliary helpers. If the current model natively supports PDF understanding, use native analysis as the primary signal.
- If the user asks for resume analysis/comparison and PDFs are uploaded, call list_uploaded_resume_pdfs first.
- Then call extract_resume_pdf_structured_info proactively; call extract_resume_pdf_text when you need verbatim evidence, conflict resolution, or higher confidence.
- For resume ranking/comparison with uploaded PDFs, call at least one PDF tool before the final recommendation.
- Do not ask the user to manually paste resume details if they are available in uploaded PDFs.
When users ask for current time, call get_server_time.
When users ask for screening criteria, call get_resume_review_framework.
Do not fabricate unavailable facts.

${jdContext}

${autoJdContext}

Resume files uploaded: ${uploadedResumeFiles ? "yes" : "no"}.`,
    messages: await convertToModelMessages(messages),
    stopWhen: stepCountIs(8),
    tools: {
      get_server_time: tool({
        description:
          "Get the current server-side date time. Use this when users ask for current time/date.",
        inputSchema: z.object({
          timezone: z
            .string()
            .describe("IANA timezone, e.g. Asia/Shanghai")
            .optional(),
        }),
        execute: async ({ timezone }) => {
          const resolvedTimeZone = timezone?.trim() || "Asia/Shanghai";

          try {
            return {
              now: new Intl.DateTimeFormat("zh-CN", {
                dateStyle: "full",
                timeStyle: "long",
                timeZone: resolvedTimeZone,
              }).format(new Date()),
              timezone: resolvedTimeZone,
            };
          } catch {
            return {
              now: new Intl.DateTimeFormat("zh-CN", {
                dateStyle: "full",
                timeStyle: "long",
                timeZone: "UTC",
              }).format(new Date()),
              timezone: "UTC",
              warning:
                "Invalid timezone provided. Fallback to UTC was applied.",
            };
          }
        },
      }),

      get_resume_review_framework: tool({
        description:
          "Return a practical internship resume screening framework with weighted dimensions.",
        inputSchema: z.object({
          seniority: z
            .enum(["intern", "junior", "mid", "senior"])
            .optional(),
          targetRole: z
            .string()
            .describe("Target role, e.g. frontend engineer")
            .optional(),
        }),
        execute: async ({ seniority, targetRole }) => {
          const level = seniority ?? "intern";

          return {
            targetRole: targetRole ?? "software engineer intern",
            seniority: level,
            dimensions: [
              {
                name: "Impact & outcomes",
                weight: 30,
                checklist: [
                  "Quantified business or product impact",
                  "Clear ownership and scope",
                  "Strong action-result phrasing",
                ],
              },
              {
                name: "Technical depth",
                weight: 25,
                checklist: [
                  "Concrete stack details",
                  "Architecture/tradeoff evidence",
                  "Performance, reliability, or scaling work",
                ],
              },
              {
                name: "Role relevance",
                weight: 20,
                checklist: [
                  "Matches target role keywords",
                  "Projects align with job scope",
                  "Order and emphasis support role fit",
                ],
              },
              {
                name: "Structure & readability",
                weight: 15,
                checklist: [
                  "Concise bullet writing",
                  "Consistent timeline and formatting",
                  "Easy-to-scan hierarchy",
                ],
              },
              {
                name: "Signal credibility",
                weight: 10,
                checklist: [
                  "No exaggerated claims",
                  "Verifiable links or artifacts",
                  "Clear context for achievements",
                ],
              },
            ],
          };
        },
      }),

      list_uploaded_resume_pdfs: tool({
        description:
          "Auxiliary helper: list uploaded PDF resumes with index and filename. If multiple files are present, call this proactively to avoid filename ambiguity even when the model can read PDFs natively.",
        inputSchema: z.object({}),
        execute: async () => ({
          count: uploadedResumePdfs.length,
          resumes: availableResumeNames,
        }),
      }),

      extract_resume_pdf_text: tool({
        description:
          "Auxiliary helper: extract plain text from uploaded PDF resume(s). If the model supports native PDF analysis, treat native analysis as primary and use this tool for quote-level evidence, cross-checking, conflict resolution, and confidence improvement. Prefer calling it proactively for comparisons.",
        inputSchema: z.object({
          maxChars: z
            .number()
            .int()
            .min(2000)
            .max(30000)
            .optional()
            .describe("Maximum characters to return per resume"),
          resumeName: z
            .string()
            .optional()
            .describe("Resume filename keyword or 1-based index"),
        }),
        execute: async ({ maxChars, resumeName }) => {
          if (uploadedResumePdfs.length === 0) {
            return {
              count: 0,
              message: "No uploaded PDF resumes found.",
              resumes: [] as unknown[],
            };
          }

          const selected = selectResumeFiles(resumeName);

          if (selected.length === 0) {
            return {
              count: 0,
              message: `No resume matched selector: ${resumeName}`,
              resumes: availableResumeNames,
            };
          }

          const textLimit = maxChars ?? 12000;
          const resumes = await Promise.all(
            selected.map(async (file) => {
              try {
                const parsed = await parseUploadedResume(file);
                const clipped = clipResumeText(parsed.text, textLimit);

                return {
                  excerpt: clipped.text,
                  filename: parsed.filename,
                  pageCount: parsed.pageCount,
                  textChars: parsed.totalTextChars,
                  truncated: clipped.truncated,
                };
              } catch (error) {
                return {
                  error:
                    error instanceof Error
                      ? error.message
                      : "Failed to parse resume PDF.",
                  filename: file.filename,
                };
              }
            })
          );

          return {
            count: resumes.length,
            resumes,
          };
        },
      }),

      extract_resume_pdf_structured_info: tool({
        description:
          "Auxiliary helper: extract structured candidate information from uploaded PDF resume(s), including contact, education, skills, and highlights. If native PDF understanding is available, keep native analysis as primary but call this tool proactively to produce consistent structured fields for scoring and side-by-side comparison.",
        inputSchema: z.object({
          resumeName: z
            .string()
            .optional()
            .describe("Resume filename keyword or 1-based index"),
        }),
        execute: async ({ resumeName }) => {
          if (uploadedResumePdfs.length === 0) {
            return {
              count: 0,
              message: "No uploaded PDF resumes found.",
              resumes: [] as unknown[],
            };
          }

          const selected = selectResumeFiles(resumeName);

          if (selected.length === 0) {
            return {
              count: 0,
              message: `No resume matched selector: ${resumeName}`,
              resumes: availableResumeNames,
            };
          }

          const resumes = await Promise.all(
            selected.map(async (file) => {
              try {
                const parsed = await parseUploadedResume(file);

                return {
                  filename: parsed.filename,
                  pageCount: parsed.pageCount,
                  structured: extractResumeStructuredInfo(parsed.text),
                };
              } catch (error) {
                return {
                  error:
                    error instanceof Error
                      ? error.message
                      : "Failed to parse resume PDF.",
                  filename: file.filename,
                };
              }
            })
          );

          return {
            count: resumes.length,
            resumes,
          };
        },
      }),
    },
  });

  return result.toUIMessageStreamResponse({
    sendReasoning: true,
    sendSources: true,
  });
}
